HASHMAP:
1) TwoSum = curNum + x = target then x = target - curNum , Use hashmap to lookUp
2) ValidAnagram = use count array, loop through both strings and validate the counting of each char ,check if the count is zero for all the char
3) RansomNote = same as ValidAnagram but check in second loop
4) IsIsomorphic = create two map arrays , add the index+1(the position ) to the ascii value of the map array ,if both the map1 and map2 of
                    a particular element is not matching return false
5) ContainsDup2 = a) Using Hashset for sliding window for add and remove when i>=k conditon
                  b) Using hashmap for i-curval <=k condition
6) LongestConsecutiveSequence = a) use sorting method , iterate through the sequence and store the max count
                                b) use HashSet to find the start seq element - num-1 not exist and store the max sequence length


6) HappyNumber = The happy number sequence forms a infinite cyclic pattern if its not a happy number
                 a) Using Floyds Hare and Tortoise algo but in do while
                 b) Using hashset to add the square sum till any element except 1 comes again

ARRAYS AND STRINGS:
1) MergeTwoSortedArrays = Reverse iteration, Compare n-1 and m-1 and swap to last(m-n-1)
2) RemoveElements = keep track of targetval index and nonVal and swap
3) RemoveDuplicates = start from 1,track unique element index, change if a[j] != a[j-1]
4) MajorityElement = a)use BoyerMoore Algorithm, b)sort array and the middle element , c)hashmap!! hashmap!!
5) BestTimeSellStock = find the maxProfit by subracting the min element and curElement while in a single loop
6) LongestCommonPrefix = sort array and iterate through first and last element and find the common substring
7) FIndFirstOccurenceOfString = loop through the string with the substring,if they are equal count++ else count = 0 & start i = i-count
                               exit when the count == len(substring)
8) RomanToInteger = map all the values,if x < x+1 then ans-=val else ans+=val
9) RemoveDuplicates2 = use two pointers ,cur = 2,prev = 1, if cur == last two elements then move on , else prev++ and swap with the cur
                       move on with the cur;
10) LengthOfLastString = iterate from last, check if its a char count++ when a empty space is reached break;
11) RotateArray = reverse the last K elements and first 0 to k-1 elements seperately and reverse the whole array
12) BestTimeSellStock2 = add maxProfit when prices[i] > prices[i-1]
13) ReverseWordsInString = a) Two pointes swap String array and use String.join()
                           b) Use String builder and append
14) JumpGame = calculate maxJump of each element and store the maxJump check if we can reach above the current index


TWO POINTERS :
1) ValidPalindrome = use i and j ,while loop from start(i) and end(j) only consider alphanumerics and check if equal
2) IsSubSequence = use i for s and j for t,loop through t while finding if each of s exist ,return with if i = len of s
3) TwoSum2 = use start and end ,add the elements in start and end ,if greater then end-- ,if lesser start++
4) ContainerWithWater = i and j , find minheight and max area , loop from left till greater element than min height same for right
                        find max area again and repeat

STACKS:
1) ValidParentheses : use a stack, push closing when opening is found ,if closing is found check (if empty return false or is the top stack
                        doesnt match then return false)


LINKEDLIST:
1) LinkedListCycle : a)HashMap - iterate through the head if element already in hashmap return true else put the head in the hashmap
                     b)Floyds Tortoise and hare algorithm

2) MergeTwoSortedList : create a dummy for head and temp for iterating and loop through both the list while comparing the values
3) AddTwoNumbers : Iterate while(l1 != null || l2 != null || carry !=0) update carry and sum and add it in new dummy nodeList if no element
                   then 0 and if no next element then null

BINARY SEARCH :
1) Search Insert Position : use classic binary search but return start at the last

BINARY SEARCH TREE :
1) FindMinDif : traverse using inOrder ,keep track of prev node and keep checking the min dif

BINARY TREE GENERAL :
1) MaximumDepth : use recursion postorder with if(rlen >  llen)return (rlen+1); else return (llen + 1); for return
2) SameTree : inorder but middle is to check if both treenodes are same
3) InvertTree : swap treeNodes with preorder
4) PathSum : inOrder , iterate while checking if the current val == target-rootval , return left||right


INTERVALS:
1)SummaryRanges : iterate,start == nums[i], move till the they are in a sequence , print the start and end(nums[i])


MATH:
1) Sqrt : a) use Newtons algorithm
          b) Binary Search
2) IsPalindrome : a) half iteration using while loop (original > reverse) and return with normal and /10 expression
                  b) finding the significant 10s multiple and chopping left and right while comparing
3) PlusOne : if the unit digit is less than 9 ele++ and return else make it zero , after the loop ends the array will be filled with 9
             so just create new array with +1 length than previous and add 1 to the first element



ALGORITHMS :
1) Boyer Moore Algorithm - finds the major element
2) Floyd's Tortoise and hare - finds if a loop exist
3) Sliding Window
4) Peak and Valley approach
5) Two Pointers
6) Depth First Search (Inorder , preorder, postorder)




TIPS:
* String is an object so every method and operation takes more time and space use stringbuffer or stringbuilder
* if needed to use length or size method multiple times save it ina var and use it more less memmory and time usage
* Creating a dummy node as a head and a temp node for iterating does not take much memory both are O(1) independently
* Using an array is better than a hashMap for mapping
* String is an object so need to use .equals() to compare
* .put() in hashmap return NULL if new pair is added else return the newly updated value
* Map map = new HashMap(); dynamic input key and value types
* AutoBoxing of int is -128 to 127 ,so be careful while using primitive datatypes in a Collection or data structure;
* Can use HashSet for sliding window problems
* Creating a wrapper object takes more time and space than to create a primitive data type
* Instead of adding and checking ,we can check and then add for better efficiency
* Self checking and swaping of elements is a option too
* While using iteration for arrays try to use the elements in the previous of cur index ,nothing after the cur indx
* set.add(n) return if the n is already in the set or not in boolean
* We can actually swap null with some object

